# goit-algo-hw-04
DZ2_4

# Порівняльний аналіз алгоритмів сортування: вставками, злиттям та Timsort

## Сортування вставками (Insertion sort)

- Найгірший випадок: `O(n^2)`
- Середній випадок: `O(n^2)`
- Найкращий випадок (майже відсортований масив): `O(n)`

Алгоритм простий у реалізації, але погано масштабується на великих масивах.

## Сортування злиттям (Merge sort)

- Найгірший випадок: `O(n log n)`
- Середній випадок: `O(n log n)`
- Найкращий випадок: `O(n log n)`

Алгоритм ділить масив навпіл, рекурсивно сортує частини і розширювано зливає їх. Має гарантовану `O(n log n)` складність, але потребує додаткової пам’яті.

## Timsort (Python `sorted` / `.sort()`)

Timsort — гібридний алгоритм, який поєднує:

- сортування вставками на малих або майже відсортованих підмасивах;
- сортування злиттям для об’єднання відсортованих фрагментів (runs).

Складність:

- Найгірший випадок: `O(n log n)`
- Середній випадок: `O(n log n)`
- Найкращий випадок (майже відсортовані дані): близько `O(n)`

Це робить Timsort дуже ефективним для «реальних» даних, де часто зустрічаються впорядковані підпослідовності.

---

# Опис реалізації

У файлі `main.py` реалізовано:

- `insertion_sort(arr)` — класичний алгоритм сортування вставками (in-place);
- `merge_sort(arr)` і допоміжна функція `merge(left, right)` — рекурсивна реалізація сортування злиттям, яка повертає новий відсортований список;
- використання вбудованої функції `sorted` як представника Timsort;
- генерація трьох типів наборів даних:
  - `random` — випадкові значення;
  - `sorted` — вже відсортований масив;
  - `reversed` — масив, відсортований у зворотному порядку;
- вимірювання часу для розмірів масиву: `1000`, `5000`, `10000`.

Замір часу виконання виконується за допомогою `timeit.timeit`, де кожний алгоритм запускається кілька разів на копії одного й того ж масиву.

---

# Очікуваний результат

При запуску скрипта очікуються такі загальні тенденції:

1. **Insertion sort**
   - На малих масивах може працювати терпимо.
   - На більших розмірах (`5000`, `10000`) різко програє за часом, особливо на випадкових і зворотно відсортованих масивах.
   - На вже відсортованих масивах показує кращий час, але все одно гірший за Timsort.

2. **Merge sort**
   - Значно швидший за insertion sort на великих масивах.
   - Час росте приблизно як `O(n log n)`.
   - Чутливість до типу вхідних даних (random / sorted / reversed) менша, ніж у insertion sort, бо схема поділу однакова.

3. **Timsort (`sorted`)**
   - На всіх типах даних показує час, близький до або кращий за merge sort.
   - На вже відсортованих і майже відсортованих даних зазвичай дає помітно кращі результати завдяки використанню сортування вставками для малих «runs» та виявленню вже впорядкованих фрагментів.
   - На великих масивах стабільно перемагає insertion sort і в більшості випадків не гірший за merge sort, а часто й швидший.

Таким чином, емпіричні результати підтверджують теоретичні очікування:

- квадратична складність insertion sort робить його непридатним для великих вхідних даних;
- merge sort демонструє `O(n log n)` поведінку;
- Timsort, завдяки поєднанню підходів і оптимізаціям під реальні дані, є найефективнішим з трьох у більшості практичних випадків.

---

# Висновки

1. **Insertion sort**:
   - Підходить лише для малих масивів або як допоміжний алгоритм усередині інших методів.
   - На великих наборах даних програє за часом як merge sort, так і Timsort через `O(n^2)` складність.

2. **Merge sort**:
   - Має стабільну `O(n log n)` складність.
   - Добре масштабується на великі масиви.
   - Потребує додаткової пам’яті для злиття.

3. **Timsort (Python `sorted`)**:
   - Поєднує переваги сортування вставками і сортування злиттям.
   - Використовує сортування вставками на малих підмасивах та злиття вже відсортованих фрагментів.
   - Показує найкращий або близький до найкращого час виконання на всіх протестованих типах даних.
   - Особливо ефективний на вже частково впорядкованих масивах, що часто зустрічається в реальних задачах.

